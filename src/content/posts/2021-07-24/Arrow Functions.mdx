---
path: "/blog/arrow-functions"
date: "2021-07-24"
title: "Arrow Functions"
image: "images/preview.png"
---

Arrow Functions provide two main benefits or features compared to regular function definitions: more concise syntax, and lexical scoping of "this". Let's take a quick look at both.

## Arrow Function Syntax

Arrow functions provide a more concise way to define functions. Arrow functions are especially useful when declaring a callback function. Take a look at the following comparison:

```javascript
// Traditional function definition
setTimeout(function () {
  console.log("I will print after 100ms");
}, 100);

// Arrow function definition
setTimeout(() => {
  console.log("I will also print after 100ms");
}, 100);
```

### Syntax variations:

Depending on the number of arguments and the content of the function, arrow functions can be declared in a number of ways:

```javascript
// No arguments
const func = () => {
  // function body
};

// One argument - no parenthesis are needed for one argument
const func = x => {
  // function body
};

// Two arguments - parenthesis are needed
const func = (x, y) => {
  // function body
};

// Implicit return
const func = (x, y) => x + y;
```

### Implicit returns

Note the last version in the above code block. If an arrow function contains a single expression, you can exclude curly braces and a return statement. To better understand this, its important to understand the difference between an "Expression" and a "Statement".

<br />

In basic terms, an "Expression" resolves to a value, e.g. 3 + 4. A "Statement" is a set of instructions, e.g. `document.querySelector('.list').innerHTML = "Hello world"`.

<br />

If an arrow function only contains a single expression, we can omit the **return** keyword. This is particularly useful in simple callbacks, for instance in a map or filter function:

```javascript
const array = [1, 2, 3, 4];

// Arrow function
const doubledArray = array.map(item => item * 2);

// Traditional function
const doubledArray = array.map(function (item) {
  return item * 2;
});
```

## Lexical scoping

Arrow functions also have an effect on how the **this** keyword works, more specifically what it refers to.

<!--

## Lexical scoping of this

In the context of _functions_ and _this_, lexical scoping basically means that a function gets it’s value of _this_ from the surrounding code (the actual definition is much more complicated and involves how the JavaScript engine compiles code at run-time).

Normal functions get their value of _this_ from the context in which they are **called**. This means that if we want to access the _this_ keyword from the context in which the function was **defined**, we would have to bind _this_ to the function using the _.bind(this)_ method.

**Arrow functions** get their value of _this_ from the context in which they are **defined**. _This_ cannot be bound to an **arrow function**.

Don’t worry if this doesn’t make much sense, it probably just means that you haven’t had to deal with lexical scoping yet. But if you run into problems using _this_, or see code that uses the _.bind(this)_ method, or you see _var that = this_ then it’s likely that you are running into problems with the scoping of _this_. In that case, using **arrow functions** may solve your problems.

In summary, using **arrow functions** can help us write cleaner, more concise code. Hopefully this article has also helped you to understand how **arrow functions** work with the _this_ keyword.

I love using arrow functions. But just remember that not every function can or should be written as an **arrow function**. An example of this is when declaring methods for an object, which we’ll look at in the next article. -->
